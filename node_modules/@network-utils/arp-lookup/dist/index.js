"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isType = exports.fromPrefix = exports.toIP = exports.toMAC = exports.getTable = exports.isPrefix = exports.isMAC = void 0;
const child_process_1 = require("child_process");
const net_1 = require("net");
/**
 * Normalizes a MAC address so that `-` is
 * replaced `:` and is converted to lower case
 *
 * Example: `04-A1-51-1B-12-92` => `04:a1:51:1b:12:92`
 * @param mac The MAC Address to normalize
 */
const normalize = (mac) => mac.replace(/\-/g, ':').toLowerCase();
/**
 * Fixes the non compliant MAC addresses returned on Apple systems by adding a leading 0 on parts of the address
 * @param mac The MAC address to FIX
 */
const fixMAC = (mac) => normalize(mac)
    .split(':')
    .map((part) => (part.length === 1 ? '0' + part : part))
    .join(':');
/**
 * Checks if a MAC address is valid
 * @param mac The MAC address to validate
 */
const isMAC = (mac) => /^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$/i.test(mac);
exports.isMAC = isMAC;
/**
 * Checks if a MAC address prefix is valid
 * @param prefix The prefix to validate
 */
const isPrefix = (prefix) => /^([0-9A-F]{2}[:-]){2}([0-9A-F]{2})$/i.test(prefix);
exports.isPrefix = isPrefix;
/**
 * Retrieves the networks' arp table
 */
function getTable() {
    return new Promise((resolve, reject) => {
        (0, child_process_1.exec)('arp -a', (err, rawArpData) => {
            if (err) {
                reject(err);
                return;
            }
            const rows = rawArpData.split('\n');
            const table = [];
            for (const row of rows) {
                let ip;
                let mac;
                let type;
                if (process.platform.substring(0, 3) === 'win') {
                    ;
                    [ip, mac, type] = row.trim().replace(/\s+/g, ' ').split(' ');
                }
                else {
                    // Parse the rows as they are returned on unix (Mac or Linux) systems
                    const match = /.*\((.*?)\) (?:\w+) (.{0,17}) (?:\[ether\]|on)/g.exec(row);
                    if (match && match.length === 3) {
                        ip = match[1];
                        mac = fixMAC(match[2]);
                        type = 'unknown';
                    }
                    else {
                        continue;
                    }
                }
                /*
                  If `ip` isn't a valid IP address or `mac` isn't
                  a valid MAC address then this is a header
                  row (e.g. "Interface: 192.168.137.1 --- 0x2")
                  so we can just ignore it.
                */
                if (!(0, net_1.isIP)(ip) || !(0, exports.isMAC)(mac))
                    continue;
                table.push({
                    ip,
                    mac: normalize(mac),
                    type,
                });
            }
            resolve(table);
        });
    });
}
exports.getTable = getTable;
/**
 * Gets the MAC address for the given `ip` address
 * @param ip The IP address
 */
function toMAC(ip) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, net_1.isIP)(ip))
            throw Error('Invalid IP');
        const arpTable = yield getTable();
        const match = arpTable.find((row) => row.ip === ip);
        return match ? match.mac : null;
    });
}
exports.toMAC = toMAC;
/**
 * Gets the IP address for given `mac` address
 * @param mac The MAC address
 */
function toIP(mac) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, exports.isMAC)(mac))
            throw Error('Invalid MAC');
        mac = normalize(mac);
        const arpTable = yield getTable();
        const match = arpTable.find((row) => row.mac === mac);
        return match ? match.ip : null;
    });
}
exports.toIP = toIP;
/**
 * Returns all devices on the network with
 * the specified MAC prefix
 * @param prefix the prefix to search for
 */
function fromPrefix(prefix) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, exports.isPrefix)(prefix))
            throw Error('Invalid Prefix');
        const table = yield getTable();
        return table.filter((row) => row.mac.startsWith(prefix));
    });
}
exports.fromPrefix = fromPrefix;
function isType(type, address) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, net_1.isIP)(address) && !(0, exports.isMAC)(address))
            throw Error('Invalid address');
        if (process.platform === 'darwin' && type !== 'unknown' && process.env.NODE_ENV !== 'production')
            console.warn('[arp-lookup] `isType` will always return `false` for types other than "unknown" on darwin systems');
        if ((0, exports.isMAC)(address))
            address = normalize(address);
        const recordedType = (_b = (_a = (yield getTable()).find((row) => row.ip === address || row.mac === address)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : 'undefined';
        return type === recordedType;
    });
}
exports.isType = isType;
exports.default = {
    fromPrefix,
    getTable,
    isType,
    isIP: net_1.isIP,
    isMAC: exports.isMAC,
    isPrefix: exports.isPrefix,
    toIP,
    toMAC,
};
